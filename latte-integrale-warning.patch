--- ./code/latte/ehrhart.cpp.orig	2013-08-19 15:48:29.000000000 -0600
+++ ./code/latte/ehrhart.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -73,13 +73,13 @@ int main(int argc, char *argv[]) {
     assumeUnimodularCones[127], dualApproach[127], taylor[127], printfile[127],
     rationalCone[127], nonneg[127], Memory_Save[127], Save_Tri[127],
     Load_Tri[127], Print[127], inthull[127], cddstyle[127], grobner[127],
-    removeFiles[127], command[10000], maximum[127],  Singlecone[127], LRS[127],
+    removeFiles[127], maximum[127],  Singlecone[127], LRS[127],
     Vrepresentation[127], dilation[127], minimize[127], binary[127], 
     interior[127];
   listVector *matrix, *equations, *inequalities, *rays, *endRays, *tmpRays, *matrixTmp;
   vec_ZZ cost;
-  listVector *templistVec;
-  listCone *cones, *tmp, *tmpcones;
+  listVector *templistVec = NULL;
+  listCone *cones = NULL, *tmp, *tmpcones;
 
   latte_banner(cerr);
 
--- ./code/latte/ehrhart3.cpp.orig	2011-12-18 13:33:46.000000000 -0700
+++ ./code/latte/ehrhart3.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -33,7 +33,7 @@ void EhrhartPolyRootFinder::saveMatlab()
 	file.open(matlabCommands.c_str());
 	
 	file << "p = sym('" << poly[0] << "');\n\n" ;
-	for(int i = 1; i < poly.size(); ++i)
+	for(size_t i = 1; i < poly.size(); ++i)
 		file << "p = p + sym('" << poly[i] << " * t^" << i << "');\n";
 		
 	file << "syms t;\n";
@@ -60,7 +60,7 @@ void EhrhartPolyRootFinder::saveMaple()
 	
 	file << "Digits:=1000;\n";
 	file << "p := ";
-	for(int i = 0; i < poly.size(); ++i)
+	for(size_t i = 0; i < poly.size(); ++i)
 		file << " + " << poly[i] << "* t^" << i << " ";
 	file << ":\n";
 	file << "theRoots := fsolve(p = 0, t, complex):\n";
--- code/latte/maximize.cpp.orig	2013-08-19 15:48:29.000000000 -0600
+++ code/latte/maximize.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -73,12 +73,12 @@
     assumeUnimodularCones[127], dualApproach[127], taylor[127], printfile[127],
     rationalCone[127], nonneg[127], Memory_Save[127], Save_Tri[127],
     Load_Tri[127], Print[127], inthull[127], cddstyle[127], grobner[127],
-    removeFiles[127], command[10000], maximum[127],  Singlecone[127], LRS[127],
+    removeFiles[127], maximum[127],  Singlecone[127], LRS[127],
     Vrepresentation[127], dilation[127], minimize[127], binary[127], interior[127];
   listVector *matrix, *equations, *inequalities, *rays, *endRays, *tmpRays, *matrixTmp;
   vec_ZZ cost;
-  listVector *templistVec;
-  listCone *cones, *tmp, *tmpcones;
+  listVector *templistVec = NULL;
+  listCone *cones = NULL, *tmp, *tmpcones;
 
   latte_banner(cerr);
 
--- ./code/latte/minimize.cpp.orig	2013-08-19 15:48:29.000000000 -0600
+++ ./code/latte/minimize.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -73,12 +73,12 @@ int main(int argc, char *argv[]) {
     assumeUnimodularCones[127], dualApproach[127], taylor[127], printfile[127],
     rationalCone[127], nonneg[127], Memory_Save[127], Save_Tri[127],
     Load_Tri[127], Print[127], inthull[127], cddstyle[127], grobner[127],
-    removeFiles[127], command[10000], maximum[127],  Singlecone[127], LRS[127],
+    removeFiles[127], maximum[127],  Singlecone[127], LRS[127],
     Vrepresentation[127], dilation[127], minimize[127], binary[127], interior[127];
   listVector *matrix, *equations, *inequalities, *rays, *endRays, *tmpRays, *matrixTmp;
   vec_ZZ cost;
-  listVector *templistVec;
-  listCone *cones, *tmp, *tmpcones;
+  listVector *templistVec = NULL;
+  listCone *cones = NULL, *tmp, *tmpcones;
 
   latte_banner(cerr);
 
--- ./code/latte/ReadPolyhedron.cpp.orig	2011-12-18 13:33:46.000000000 -0700
+++ ./code/latte/ReadPolyhedron.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -1210,11 +1210,11 @@ RationalNTL ReadPolyhedronDataRecursive:
 	{
 		for(int j = 1; j < mat.NumCols(); ++i)
 			mat[i][j] = latticeBasis[i][j-1];
+	}
 
 cout << "ReadPolyhedronDataRecursive::getNormalFactor(). start here, what is matrix col." << endl;
 exit(1);
 //		assert(ddHrep->matrix[i][])
-	}
 //start here --uncomment
 //	mpz_class nDilation
 //	dilationNum = 1;
--- ./code/latte/ReadSubcones.cpp.orig	2011-12-18 13:33:46.000000000 -0700
+++ ./code/latte/ReadSubcones.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -164,7 +164,7 @@ void
 IncrementalVectorFileWriter::WriteVector(const std::vector<bool> &v)
 {
   int index;
-  assert(dimension == v.size());
+  assert(dimension >= 0 && (size_t)dimension == v.size());
   for (index = 0; index<dimension; index++) {
     stream << v[index] << " ";
   }
@@ -180,7 +180,7 @@ void
 IncrementalVectorFileWriter::WriteVector(const std::vector<int> &v)
 {
   int index;
-  assert(dimension == v.size());
+  assert(dimension >= 0 && (size_t)dimension == v.size());
   for (index = 0; index<dimension; index++) {
     stream << v[index] << " ";
   }
@@ -234,7 +234,7 @@ int SubconePrintingConeConsumer::Consume
   listVector *ray;
   for (ray = cone->rays; ray!=NULL; ray=ray->rest) {
     if (ray->index_hint >= 0
-	&& ray->index_hint < master_rays.size()
+	&& (size_t)ray->index_hint < master_rays.size()
 	&& ray->first == master_rays[ray->index_hint])
       ray_indicator[ray->index_hint] = true;
     else {
--- ./code/latte/Residue.cpp.orig	2013-08-19 15:45:20.000000000 -0600
+++ ./code/latte/Residue.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -609,7 +609,7 @@ Residue_Single_Cone(listCone* cones, int
   dim=numOfVars;
   noGsPerC=lengthListVector(cones->rays);
   int i,j;			// index or loop vars
-  long int k, m;	       //n=0,p; // extra vars to use as needed
+  long int k = -1, m;	       //n=0,p; // extra vars to use as needed
   vector<int> E(noCones);	  // E is the vector of epsilons, each 1 or -1
   vector<list<Integer> > A(noCones);	// A is the numerator vectors
 
--- ./code/latte/ResSingle.cpp.orig	2013-08-15 18:29:46.000000000 -0600
+++ ./code/latte/ResSingle.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -317,7 +317,7 @@ int ResidueFunction_Single_Cone(listCone
 	for (int i = 0;i <= DEGREE; i++)
 		Cone_Taylor_Parameters->Result[i] = 0;
 		
-	if(Residue_Parameters->Flags & PRINT	== 1)
+	if((Residue_Parameters->Flags & PRINT)	== 1)
 		 {
 		   // system_with_error_check("rm func.rat");
 	 		 //cerr << "Outputing rational functions to file" << endl;
@@ -839,7 +839,7 @@ int ResidueFunction_Single_Cone(listCone
 			
 		}
 		
-		if(Residue_Parameters->Flags & PRINT == 1)
+		if((Residue_Parameters->Flags & PRINT) == 1)
 		{
 			Rational_Function_Output_File << "x := ";
 			Final_Cone_Expression->Print_Rational_Functions_to_File( Rational_Function_Output_File );
@@ -874,7 +874,7 @@ int ResidueFunction_Single_Cone(listCone
 	
 	//Output the rational functions to file
 
-	if(Residue_Parameters->Flags & PRINT == 1)
+	if((Residue_Parameters->Flags & PRINT) == 1)
 	{
 			 
 		Rational_Function_Output_File.close ();	 
--- ./code/latte/buildPolytopes/BuildRandomPolynomials.cpp.orig	2013-08-02 15:03:37.000000000 -0600
+++ ./code/latte/buildPolytopes/BuildRandomPolynomials.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -20,7 +20,7 @@ string makeRandomMonomial(const int dim,
 	//We treat totalDegree as the amount left over...how much powers we still have to add.
 	const int stepSize = 2; //add no more than 1 powers to a term at a time.
 	vector<int> powers;
-	int i; //i = the x_i who will be getting more powers.
+	int i = 0; //i = the x_i who will be getting more powers.
 	int newPower;
 	stringstream poly;
 
--- ./code/latte/integration/burstTrie.hpp.orig	2011-12-18 13:33:41.000000000 -0700
+++ ./code/latte/integration/burstTrie.hpp	2013-09-10 12:00:00.000000000 -0600
@@ -151,7 +151,7 @@ public:
 		}
 
 		BurstTerm<T, S> *curTerm = firstTerm;
-		BurstTerm<T, S> *oldTerm;
+		BurstTerm<T, S> *oldTerm = NULL;
 
 		while (curTerm && curTerm->lessThan(newTerm, equal))
 		{
--- ./code/latte/integration/consumers.h.orig	2011-12-18 13:33:41.000000000 -0700
+++ ./code/latte/integration/consumers.h	2013-09-10 12:00:00.000000000 -0600
@@ -41,6 +41,7 @@ public:
 template <class T> class MonomialLoadConsumer : public MonomialConsumer<T> {
 public:
   MonomialLoadConsumer() {}
+  virtual ~MonomialLoadConsumer() {}
   // Take monomial and consume it.
   void ConsumeMonomial(const T& coef, int* exps) { insertMonomial(coef, exps, *monomials); }
   void setMonomialSum(monomialSum& mySum) { monomials = &mySum; }
@@ -58,7 +59,7 @@ public:
   void setFormSum(linFormSum& myForms) { formSum = &myForms; }
   void setDimension(int dimension) { if (formSum) { formSum->varCount = dimension; } }
   int getDimension() { if (formSum) { return formSum->varCount; } else { return 0; } }
-  ~FormLoadConsumer() {}
+  virtual ~FormLoadConsumer() {}
 private:
   linFormSum* formSum;
 };
@@ -90,7 +91,7 @@ public:
   void setDimension(int dimension) {if ( formProductSum) formProductSum->varCount = dimension;}
   int getDimension() {if ( formProductSum) return formProductSum->varCount; else return 0;}
   int size() {if ( formProductSum) return formProductSum->myFormProducts.size(); else return 0;}
-  ~FormProductLoadConsumer() {}
+  virtual ~FormProductLoadConsumer() {}
 private:
   linFormProductSum* formProductSum;
 };
--- ./code/latte/integration/iterators.hpp.orig	2011-12-18 13:33:41.000000000 -0700
+++ ./code/latte/integration/iterators.hpp	2013-09-10 12:00:00.000000000 -0600
@@ -134,7 +134,7 @@ public:
 		return &curTerm;
 	}
 
-	~BTrieIterator()
+	virtual ~BTrieIterator()
 	{
 		if (triePath)
 			delete[] triePath;
--- ./code/latte/integration/newIntegration.cpp.orig	2013-08-02 15:01:29.000000000 -0600
+++ ./code/latte/integration/newIntegration.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -35,10 +35,10 @@ void convertToSimplex(simplexZZ &mySimpl
 	t = line.find("[", t) + 1;
 	t = line.find("[", t) + 1;
 	temp = line.substr(t, line.find("]", t) - t);
-	for (i = 0; i < temp.length(); i++)
+	for (i = 0; (size_t) i < temp.length(); i++)
 		mySimplex.d += (temp.at(i) == ',');
 	c = 0;
-	for (i = 0; i < line.length(); i++)
+	for (i = 0; (size_t) i < line.length(); i++)
 		c += (line.at(i) == ']');
 	if (c - 2 != mySimplex.d)
 	{
@@ -51,7 +51,7 @@ void convertToSimplex(simplexZZ &mySimpl
 	{
 		temp = line.substr(index, line.find("]", index) - index + 1);
 		c = 0;
-		for (j = 0; j < temp.length(); j++)
+		for (j = 0; (size_t) j < temp.length(); j++)
 			c += (temp.at(j) == ',');
 		if (c != mySimplex.d - 1)
 		{
--- ./code/latte/integration/PolyRep.cpp.orig	2013-08-02 15:01:18.000000000 -0600
+++ ./code/latte/integration/PolyRep.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -167,7 +167,7 @@ void _parseLinForms(_FormSumConsumer<Rat
 
 	vec_ZZ coefs;
 	coefs.SetLength(varCount);
-	int degree;
+	int degree = 0;
 	RationalNTL coefficient;
 
 	for (size_t i = 1; i < line.length() - 1; i++) //ignore outermost square brackets
--- ./code/latte/integration/PolyTrie.cpp.orig	2013-08-02 15:01:23.000000000 -0600
+++ ./code/latte/integration/PolyTrie.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -364,7 +364,7 @@ void parseLinFormProducts(FormProductLoa
 	RationalNTL coefficient;
 
 	int productIndex = 0;
-	for (int i = 1; i < line.length() - 1; i++) //ignore outermost square brackets
+	for (size_t i = 1; i < line.length() - 1; i++) //ignore outermost square brackets
 	{
 		if (line[i] == '[')
 		{
@@ -446,7 +446,7 @@ void parseLinFormProducts(FormProductLoa
 //Deallocates space and nullifies internal pointers and counters
 void destroyLinFormProducts(linFormProductSum &myProd)
 {
-	for(int i = 0; i < myProd.myFormProducts.size(); ++i)
+	for(size_t i = 0; i < myProd.myFormProducts.size(); ++i)
 	{
 		destroyLinForms(myProd.myFormProducts[i]);
 	}
@@ -460,7 +460,7 @@ void destroyLinFormProducts(linFormProdu
 string printLinFormProducts(const linFormProductSum &plf)
 {
 	stringstream out;
-	for(int i = 0; i < plf.myFormProducts.size(); ++i)
+	for(size_t i = 0; i < plf.myFormProducts.size(); ++i)
 	{
 		cout << i << " started" << endl;
 		cout << printLinForms(plf[i]).c_str() << endl;
--- ./code/latte/interpolation/PolynomialInterpolation.cpp.orig	2013-08-30 11:15:33.000000000 -0600
+++ ./code/latte/interpolation/PolynomialInterpolation.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -270,5 +270,6 @@ PolynomialInterpolation & PolynomialInte
 			matrix[row][col] = rhs.matrix[row][col];
 		}
 	}//for row
+	return *this;
 }//operator=
 	
--- ./code/latte/normalize/normaliz_wrapper.cpp.orig	2013-08-19 16:29:58.000000000 -0600
+++ ./code/latte/normalize/normaliz_wrapper.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -426,7 +426,7 @@ listVector* pullOneRay(char* simplicialC
       smallCones=extractNonDominatedVectors(smallCones,mainOrbits,numOfVars);
       printf("uncovered smallCones = %d -> ",lengthListVector(smallCones));
     	
-      simplicialCones=extractSimplicialCones(simplicialCones,&smallCones,
+      simplicialCones=extractSimplicialCones(NULL,&smallCones,
     						                 dimension,numOfVars);
       printf("simplicial = %d\n",lengthListVector(simplicialCones));
       if (simplicialCones) { 
--- ./code/latte/normalize/normalize.cpp.orig	2013-08-19 17:22:00.000000000 -0600
+++ ./code/latte/normalize/normalize.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -704,6 +704,7 @@ int normalize_main(int argc, char **argv
     triang_filename = filename;
     producer = new ListConeReadingConeProducer(filename);
     triangulate_toplevel = false;
+    cone = NULL;
   }
   else {
     // Read a cone.
--- ./code/latte/valuation/PolytopeValuation.cpp.orig	2013-08-07 18:00:56.000000000 -0600
+++ ./code/latte/valuation/PolytopeValuation.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -537,7 +537,7 @@ RationalNTL PolytopeValuation::findInteg
 
 	//dilate the integrand..
     //after this call, linearForms is filled in, and constantMonomial is the constant term in the input polynomial.
-	for(int i = 0; i < originalLinearFormProducts.myFormProducts.size(); ++i)
+	for(size_t i = 0; i < originalLinearFormProducts.myFormProducts.size(); ++i)
 	{
 		linFormSum linearForms;
 		RationalNTL currentConstantMonomial;
@@ -562,7 +562,7 @@ RationalNTL PolytopeValuation::findInteg
 	triangulatePolytopeCone(); //every tiangulated vertex is now in the form (1, a1, ..., an) such that ai \in Z.
 	cerr << " starting to integrate " << linearFormProducts.myFormProducts.size() << " product of linear forms.\n";
 
-	for(int i = 0; i < linearFormProducts.myFormProducts.size(); ++i)
+	for(size_t i = 0; i < linearFormProducts.myFormProducts.size(); ++i)
 		answer.add(findIntegralProductsUsingTriangulation(linearFormProducts.myFormProducts[i])); //finally, we are ready to do the integration!
 
 	answer.div(power(dilationFactor, linearFormProducts.varCount)); //factor in the Jacobian term.
@@ -807,7 +807,7 @@ RationalNTL PolytopeValuation::findInteg
 		//cout << "int ans after lpc " << integralAns << endl;
 
 		de = 1;
-		for (i = 1; i <= dim + m; i++)
+		for (i = 1; (int) i <= dim + m; i++)
 		{
 			de = de * i;
 		} //de is (d+m)!. Note this is different from the factor in the paper because in the storage of a linear form, any coefficient is automatically adjusted by m!
--- ./code/latte/vertices/cdd.cpp.orig	2013-08-19 15:48:29.000000000 -0600
+++ ./code/latte/vertices/cdd.cpp	2013-09-10 12:00:00.000000000 -0600
@@ -174,7 +174,7 @@ void createCddIneFile(const dd_MatrixPtr
 	if ( stack.size())
 	{
 		OUT << "partial_enumeration " << stack.size();
-		for (int i = 0; i < stack.size(); ++i)
+		for (size_t i = 0; i < stack.size(); ++i)
 		{
 			OUT << " " << stack[i];
 		}
@@ -873,7 +873,6 @@ listCone* readCddEadFileFromVrep(listCon
 listCone* computeVertexCones(const char* fileName, listVector* matrix,
 		int numOfVars)
 {
-	char cddOutFileName[PATH_MAX], command[10000];
 	listCone *cones;
 
 	/* Compute vertices and edges with cdd. */
@@ -916,7 +915,6 @@ listCone* computeVertexCones(const char*
 /* ----------------------------------------------------------------- */
 listCone* computeVertexCones(const char* fileName, const dd_MatrixPtr M)
 {
-	char cddOutFileName[PATH_MAX], command[10000];
 	listCone *cones;
 
 	/* Compute vertices and edges with cdd. */
@@ -944,8 +942,6 @@ listCone* computeVertexCones(const char*
 listCone* computeVertexConesViaLrs(const char* fileName, listVector* matrix,
 		int numOfVars)
 {
-
-	char cddOutFileName[PATH_MAX], command[10000];
 	listCone *cones;
 
 	/* Compute vertices with lrs. */
